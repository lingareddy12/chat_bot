import React, { useEffect, useState } from "react";
 
// Replace with your backend URL
const API_URL = "http://localhost:8000";
 
const App = () => {
  const [sessionId, setSessionId] = useState(null); // Track session_id
  const [input, setInput] = useState("");
  const [messages, setMessages] = useState([]);
  const [functionCall, setFunctionCall] = useState([]);
  const [file, setFile] = useState(null);
  const [loading, setLoading] = useState(false);
 
  useEffect(()=> {
    startAgent()
  },[])
 
  // Start the agent (create session)
  const startAgent = async () => {
    try {
      const response = await fetch(`${API_URL}/start_agent`);
      const data = await response.json();
      if (data.session_id) {
        setSessionId(data.session_id);
        console.log("Session started with session_id:", data.session_id);
      }
    } catch (error) {
      console.error("Error starting agent:", error);
    }
  };
 
  // Send a message to the agent
 const sendMessage = async () => {
  if (!input.trim()) return;
 
  const formData = new FormData();
  formData.append("session_id", sessionId);  // Add the session_id here (using sessionId from state)
  formData.append("input_text", input);
 
  // Only append file if one is selected
  if (file) {
    formData.append("file", file);
  }
 
  try {
    const response = await fetch(`${API_URL}/run_agent`, {
      method: "POST",
      body: formData,
    });
 
    const data = await response.json();
    if (data.reply) {
      setMessages([
        ...messages,
        { sender: "user", text: input },
        { sender: "bot", text: data.reply },
      ]);
    } else {
      console.error("No reply from bot");
    }
 
    setInput(""); // Clear input
    setFile(null); // Clear file after sending
  } catch (error) {
    console.error("Error sending message:", error);
  }
};
 
const startStreaming = async () => {
  console.log("INSIDE STREAMING");
 
  // Set the user message to state
  setMessages((prevMessages) => [
    ...prevMessages,
    { sender: "user", text: input },
  ]);
  setInput("");
  // Set loading state to true to indicate that we're waiting for a response
  setLoading(true);
 
  const formData = new FormData();
  formData.append("session_id", sessionId); // Add session_id here (using sessionId from state)
  formData.append("input_text", input);     // Add the input_text (message the user typed)
 
  const signal = new AbortController().signal; // Optional: for canceling the request
 
  try {
    console.log("INSIDE try");
 
    // Initiating the fetch request to the backend that returns a stream
    const res = await fetch('http://localhost:8000/get_response', {
      // method: 'POST',  // Use POST method to send the FormData
      // body: formData,  // Attach the FormData to the body
      signal,          // Pass the signal for abort control
    });
 
    const reader = res.body.getReader();
    const decoder = new TextDecoder('utf-8');
    let buffer = '';  // Buffer to hold incomplete chunks
 
    while (true) {
      const { value, done } = await reader.read();  // Read the stream
      if (done) break;  // Stop when the stream is done
 
      // Decode the incoming chunk and accumulate it in buffer
      buffer += decoder.decode(value, { stream: true });
 
      // Split the buffer into separate parts (each part is a valid JSON object)
      const parts = buffer.split('\n');
      buffer = parts.pop();  // Keep the last incomplete chunk in buffer
 
      // Process each complete part
      for (const part of parts) {
        try {
          const json = JSON.parse(part);  // Parse the JSON chunk
          console.log("Received chunk:", json);
 
          // Process the data based on the type
 
          // FOR FUNCTION CALL
          if (json["type"] === "function_call") {
            console.log("Function Call received:", json);
            setFunctionCall(json);  // Handle function call in a separate state if needed
            setMessages((prevMessages) => [
              ...prevMessages,
              { sender: "function_call", text: `${json.name}` },
            ]);
          }
          // FOR TEXT
          else if (json["type"] === "text") {
            setMessages((prevMessages) => [
              ...prevMessages,
              { sender: "text", text: `${json.text}` },
            ]);
          }
          // FOR TOOL
          else if (json["type"] === "tool_confirmation") {
            setMessages((prevMessages) => [
              ...prevMessages,
              { sender: "tool_confirmation", name: `${json.name}`, hint: `${json.hint}` },
            ]);
          }
          // FOR FUNCTION RESPONSE
          else if (json["type"] === "function_response") {
            setMessages((prevMessages) => [
              ...prevMessages,
              { sender: "function_response", text: `${json.name}` },
            ]);
          }
          else {
            console.log('Unknown type:', json);
          }
        } catch (error) {
          console.error("Error parsing JSON:", error);
        }
      }
    }
   
  } catch (error) {
    console.error("Error during streaming:", error);
  } finally {
    // Stop loading after the response is done
    setLoading(false);
  }
};
 
  return (
    <div className=" p-6 max-w-xl mx-auto bg-white rounded-lg shadow-lg">
      <h1 className="text-3xl font-semibold text-center text-gray-800 mb-6">Chatbot Application</h1>
      {/* Messages Display */}
      <div className="chat-box max-h-96 overflow-y-auto mb-4 p-4 border border-gray-300 rounded-lg">
  {messages.map((msg, index) => (
    <div key={index} className={`mb-2 ${msg.sender === "user" ? "text-right" : "text-left"}`}>
      <div
        className={`inline-block px-4 py-2 rounded-lg ${
          msg.sender === "user"
            ? "bg-blue-100" // User message style
            : msg.sender === "function_call"
            ? "bg-yellow-100" // Function Call message style
            : msg.sender === "text"
            ? "bg-gray-200" // Bot text style
            : msg.sender === "function_response"
            ? "bg-orange-200" // Bot text style
            : msg.sender === "tool_confirmation"
            ? "bg-green-100" // Tool Confirmation message style
            : "bg-green-100" // Default for tool_confirmation and function_response
        }`}
      >
        <p className="text-sm">
          {/* Conditional rendering for message types */}
 
          {/* User Message */}
          {msg.sender === "user" && (
            <>
              <strong>User: </strong>{msg.text}
            </>
          )}
 
          {/* Bot Text Response */}
          {msg.sender === "text" && (
            <>
              <strong>Bot: </strong>{msg.text}
            </>
          )}
 
          {/* Function Call */}
          {msg.sender === "function_call" && (
            <>
              <strong>Function Call: </strong>
              <span>{msg.text}</span>
            </>
          )}
 
          {/* Tool Confirmation */}
          {msg.sender === "tool_confirmation" && (
            <div className="tool-confirmation p-4 bg-yellow-50 rounded-lg border border-gray-300 mt-2">
              <h3 className="font-semibold text-xl">{msg.name}</h3>
              <p className="text-gray-700">{msg.hint}</p>
             
              {/* Optional Text Input */}
              <input
                type="text"
                value={input}
                onChange={(e) => setInput(e.target.value)}
                placeholder="Optional input..."
                className="w-full mt-2 p-2 border border-gray-300 rounded-md"
              />
             
              <div className="flex justify-between gap-2 mt-4">
                <button
               
                  onClick={() => startStreaming()}  // Confirm handler function
                  className="bg-green-500 text-white px-4 py-2 rounded-md hover:bg-green-600"
                >
                  Confirm
                </button>
                <button
                  onClick={() => handleCancel(msg)}  // Cancel handler function
                  className="bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600"
                >
                  Cancel
                </button>
              </div>
            </div>
          )}
 
          {/* Function Response */}
          {msg.sender === "function_response" && (
            <>
              <strong>Function Response: </strong>
              <span>{msg.text}</span>
            </>
          )}
        </p>
      </div>
    </div>
  ))}
</div>
 
 
 
 
      {/* Input Section */}
      <div className="input-box flex flex-col gap-3">
        <input
          type="text"
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Type your message..."
          className="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
        />
        <input
          type="file"
          onChange={(e) => setFile(e.target.files[0])}
          className="p-3 border border-gray-300 rounded-md"
        />
        <button
  onClick={()=>{startStreaming();console.log("CLICKED")}}
  className="w-full bg-green-500 text-white py-2 px-4 rounded-md hover:bg-green-600 transition duration-200 flex items-center justify-center gap-2"
>
  <span className="material-symbols-outlined">send</span>  {/* This is the Send icon */}
  Send
</button>
      </div>
    </div>
  );
};
 
export default App;
